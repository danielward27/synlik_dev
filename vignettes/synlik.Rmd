
<!--
%\VignetteEngine{knitr::docco_linear}
%\VignetteIndexEntry{Vignette}
-->
  
  An Introduction to **synlik** package
=======================================
  
  
  ```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(out.extra='style="display:block; margin: auto"', fig.align="center")
```


Introduction
------------
  
Package that provides Synthetic Likelihood methods for intractable likelihoods. The package is meant to be 
as general purpose as possible: as long as you are able to simulate data from your model you should be able to fit it.


Creating a **synlik** object
----------------------------
  A `"synlik"` object is mainly composed of the `"simulator"`, which is the function that simulates data from the model of interest.
  In addition, it is possible to specify an additional function `"summaries"`, which transforms the data generated by `"simulator"` into 
  summary statistics. The `"simulator"` can generate any kind of output, as long as `"summaries"` is able to transform it into a matrix
  where each row is a simulated vector of statistics. If `"summaries"` is not specified, then `"simulator"` has to output such a matrix.
  
  Here we set-up a `"synlik"` object representing the Ricker map. The obsevations are given by $Y_t \sim Pois(\phi * N_t)$, where the hidden
  state has the following dynamics $N_t = r N_{t-1} exp( -N_{t-1} + e_t )$. Here is how we create the object:
```{r}
library(synlik)
ricker_sl <- synlik(simulator = rickerSimul,
                    summaries = rickerStats,
                    param = c( logR = 3.8, logSigma = log(0.3), logPhi = log(10) ),
                    extraArgs = list("nObs" = 50, "nBurn" = 50)
)
```
  Here:
*  `"param"` is a named vector that contains the log-parameters that will be used by `"rickerSimul(param, nsim, extraArgs, ...)"`. 
*  `"extraArgs`" contains additional arguments required by `"rickerSimul"`, see `"?rickerSimul"` for details.

  Now we are ready to simulate data from the object:
  
```{r}
ricker_sl@data <- simulate(ricker_sl, nsim = 1)
```

  Here `"ricker_sl@data"` is just a vector, but **synlik** allows the simulator to simulate any kind of object, so it is often
  necessary incorportate an adequate plotting function into the object:
  
```{r}
ricker_sl@plotFun <- function(input, ...) plot(drop(input), type = 'l', ylab = "Pop", xlab = "Time", ...)
plot(ricker_sl)
```
 
  If we want to simulate several datasets we simply do:
  
```{r}
tmp <- simulate(ricker_sl, nsim = 10)
dim(tmp)
```

  So far we have just simulated data, not summary statistics. In this particular example `"rickerStats"` needs to be passed the data in 
  `"ricker_sl@data"` in order to be able to calculate statistics. We can do that by using the slot `"extraArgs"`:
```{r}
ricker_sl@extraArgs$obsData <- ricker_sl@data
```
 Now we are ready to simulate statistics:
```{r}
tmp <- simulate(ricker_sl, nsim = 2, stats = TRUE)
tmp
``` 
 and to check their approximate normality:
```{r}
checkNorm(ricker_sl)
```  
 
Looking at the synthetic likelihood
----------------------------- 

  If we want to estimate the value of the synthetic likelihood at a certain location in the parameter space, we do it as follows:
```{r}
slik(ricker_sl, 
           param  = c(logR = 3.8, logSigma = log(0.3), logPhi = log(10)),
           nsim    = 1e3)
```  
  
  We can also look as slices of this function wrt each parameter:
```{r}
slice(object = ricker_sl, 
      ranges = list("logR" = seq(3.5, 3.9, by = 0.01),
                    "logPhi" = seq(2, 2.6, by = 0.01),
                    "logSigma" = seq(-2, -0.5, by = 0.01)), 
      param = c(logR = 3.8, logSigma = log(0.3), logPhi = log(10)), 
      nsim = 500, multicore = FALSE)
```
  
  Finally we can have 2D slices with respect to pairs of parameters:
```{r}
slice(object = ricker_sl, 
      ranges = list("logR" = seq(3.5, 3.9, by = 0.02),
                    "logPhi" = seq(2, 2.6, by = 0.02)), 
      pairs = TRUE,
      param = c(logR = 3.8, logSigma = log(0.3), logPhi = log(10)), 
      nsim = 500, 
      multicore = TRUE)
```
  Notice that here we have used the `"multicore"` options, which distributes the computation among different cores or cluster nodes.
  Also `"slik"` provides this options, but for such a simple model it is not worth it.
   
   
Estimating the parameters by MCMC
----------------------------- 
  
 The unknown model parameters can be estimated by MCMC, using the `"smcmc"` function. Here is an example:
 
```{r}
ricker_sl <- smcmc(ricker_sl, 
                   initPar = c(3.2, -1, 2.6),
                   niter = 500, 
                   burn = 3,
                   priorFun = function(input, ...) sum(input), 
                   propCov = diag(c(0.1, 0.1, 0.1))^2, 
                   nsim = 500)
```

 If we have not reached convergence we can do some more MCMC iterations:
 
```{r}
ricker_sl <- continue(ricker_sl, niter = 500)
``` 

 Finally we can plot the MCMC output:
```{r}
addline1 <- function(parNam, ...) abline(h = ricker_sl@param[parNam], lwd = 2, lty = 2, col = 3) 
addline2 <- function(parNam, ...) abline(v = ricker_sl@param[parNam], lwd = 2, lty = 2, col = 3)

plot(ricker_sl, addPlot1 = "addline1", addPlot2 = "addline2")
``` 
 were we have added some lines indicating the position of the true parameters.